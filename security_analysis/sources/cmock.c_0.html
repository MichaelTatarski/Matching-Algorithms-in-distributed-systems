
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>cmock.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* ==========================================</a>
<a name="ln2">    CMock Project - Automatic Mock Generation for C</a>
<a name="ln3">    Copyright (c) 2007 Mike Karlesky, Mark VanderVoord, Greg Williams</a>
<a name="ln4">    [Released under MIT License. Please refer to license.txt for details]</a>
<a name="ln5">========================================== */</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;cmock.h&quot;</a>
<a name="ln8"> </a>
<a name="ln9">/* public constants to be used by mocks */</a>
<a name="ln10">const char* CMockStringOutOfMemory = &quot;CMock has run out of memory. Please allocate more.&quot;;</a>
<a name="ln11">const char* CMockStringCalledMore  = &quot;Called more times than expected.&quot;;</a>
<a name="ln12">const char* CMockStringCalledLess  = &quot;Called fewer times than expected.&quot;;</a>
<a name="ln13">const char* CMockStringCalledEarly = &quot;Called earlier than expected.&quot;;</a>
<a name="ln14">const char* CMockStringCalledLate  = &quot;Called later than expected.&quot;;</a>
<a name="ln15">const char* CMockStringCallOrder   = &quot;Called out of order.&quot;;</a>
<a name="ln16">const char* CMockStringIgnPreExp   = &quot;IgnoreArg called before Expect.&quot;;</a>
<a name="ln17">const char* CMockStringPtrPreExp   = &quot;ReturnThruPtr called before Expect.&quot;;</a>
<a name="ln18">const char* CMockStringPtrIsNULL   = &quot;Pointer is NULL.&quot;;</a>
<a name="ln19">const char* CMockStringExpNULL     = &quot;Expected NULL.&quot;;</a>
<a name="ln20">const char* CMockStringMismatch    = &quot;Function called with unexpected argument value.&quot;;</a>
<a name="ln21"> </a>
<a name="ln22">/* private variables */</a>
<a name="ln23">#ifdef CMOCK_MEM_DYNAMIC</a>
<a name="ln24">static unsigned char*         CMock_Guts_Buffer = NULL;</a>
<a name="ln25">static CMOCK_MEM_INDEX_TYPE   CMock_Guts_BufferSize = CMOCK_MEM_ALIGN_SIZE;</a>
<a name="ln26">static CMOCK_MEM_INDEX_TYPE   CMock_Guts_FreePtr = CMOCK_MEM_ALIGN_SIZE;</a>
<a name="ln27">#else</a>
<a name="ln28">static unsigned char          CMock_Guts_Buffer[CMOCK_MEM_SIZE + CMOCK_MEM_ALIGN_SIZE];</a>
<a name="ln29">static CMOCK_MEM_INDEX_TYPE   CMock_Guts_BufferSize = CMOCK_MEM_SIZE + CMOCK_MEM_ALIGN_SIZE;</a>
<a name="ln30">static CMOCK_MEM_INDEX_TYPE   CMock_Guts_FreePtr = CMOCK_MEM_ALIGN_SIZE;</a>
<a name="ln31">#endif</a>
<a name="ln32"> </a>
<a name="ln33">/*-------------------------------------------------------</a>
<a name="ln34"> * CMock_Guts_MemNew</a>
<a name="ln35"> *-------------------------------------------------------*/</a>
<a name="ln36">CMOCK_MEM_INDEX_TYPE CMock_Guts_MemNew(CMOCK_MEM_INDEX_TYPE size)</a>
<a name="ln37">{</a>
<a name="ln38">  CMOCK_MEM_INDEX_TYPE index;</a>
<a name="ln39"> </a>
<a name="ln40">  /* verify arguments valid (we must be allocating space for at least 1 byte, and the existing chain must be in memory somewhere) */</a>
<a name="ln41">  if (size &lt; 1)</a>
<a name="ln42">    return CMOCK_GUTS_NONE;</a>
<a name="ln43"> </a>
<a name="ln44">  /* verify we have enough room */</a>
<a name="ln45">  size = size + CMOCK_MEM_INDEX_SIZE;</a>
<a name="ln46">  if (size &amp; CMOCK_MEM_ALIGN_MASK)</a>
<a name="ln47">    size = (size + CMOCK_MEM_ALIGN_MASK) &amp; ~CMOCK_MEM_ALIGN_MASK;</a>
<a name="ln48">  if ((CMock_Guts_BufferSize - CMock_Guts_FreePtr) &lt; size)</a>
<a name="ln49">  {</a>
<a name="ln50">#ifndef CMOCK_MEM_DYNAMIC</a>
<a name="ln51">    return CMOCK_GUTS_NONE; /* nothing we can do; our static buffer is out of memory */</a>
<a name="ln52">#else</a>
<a name="ln53">    /* our dynamic buffer does not have enough room; request more via realloc() */</a>
<a name="ln54">    CMOCK_MEM_INDEX_TYPE new_buffersize = CMock_Guts_BufferSize + CMOCK_MEM_SIZE + size;</a>
<a name="ln55">    unsigned char* new_buffer = realloc(CMock_Guts_Buffer, (size_t)new_buffersize);</a>
<a name="ln56">    if (new_buffer == NULL)</a>
<a name="ln57">      return CMOCK_GUTS_NONE; /* realloc() failed; out of memory */</a>
<a name="ln58">    CMock_Guts_Buffer = new_buffer;</a>
<a name="ln59">    CMock_Guts_BufferSize = new_buffersize;</a>
<a name="ln60">#endif</a>
<a name="ln61">  }</a>
<a name="ln62"> </a>
<a name="ln63">  /* determine where we're putting this new block, and init its pointer to be the end of the line */</a>
<a name="ln64">  index = CMock_Guts_FreePtr + CMOCK_MEM_INDEX_SIZE;</a>
<a name="ln65">  *(CMOCK_MEM_INDEX_TYPE*)(&amp;CMock_Guts_Buffer[CMock_Guts_FreePtr]) = CMOCK_GUTS_NONE;</a>
<a name="ln66">  CMock_Guts_FreePtr += size;</a>
<a name="ln67"> </a>
<a name="ln68">  return index;</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">/*-------------------------------------------------------</a>
<a name="ln72"> * CMock_Guts_MemChain</a>
<a name="ln73"> *-------------------------------------------------------*/</a>
<a name="ln74">CMOCK_MEM_INDEX_TYPE CMock_Guts_MemChain(CMOCK_MEM_INDEX_TYPE root_index, CMOCK_MEM_INDEX_TYPE obj_index)</a>
<a name="ln75">{</a>
<a name="ln76">  CMOCK_MEM_INDEX_TYPE index;</a>
<a name="ln77">  void* root;</a>
<a name="ln78">  void* obj;</a>
<a name="ln79">  void* next;</a>
<a name="ln80"> </a>
<a name="ln81">  if (root_index == CMOCK_GUTS_NONE)</a>
<a name="ln82">  {</a>
<a name="ln83">    /* if there is no root currently, we return this object as the root of the chain */</a>
<a name="ln84">    return obj_index;</a>
<a name="ln85">  }</a>
<a name="ln86">  else</a>
<a name="ln87">  {</a>
<a name="ln88">    /* reject illegal nodes */</a>
<a name="ln89">    if ((root_index &lt; CMOCK_MEM_ALIGN_SIZE) || (root_index &gt;= CMock_Guts_FreePtr))</a>
<a name="ln90">    {</a>
<a name="ln91">      return CMOCK_GUTS_NONE;</a>
<a name="ln92">    }</a>
<a name="ln93">    if ((obj_index &lt; CMOCK_MEM_ALIGN_SIZE) || (obj_index &gt;= CMock_Guts_FreePtr))</a>
<a name="ln94">    {</a>
<a name="ln95">      return CMOCK_GUTS_NONE;</a>
<a name="ln96">    }</a>
<a name="ln97"> </a>
<a name="ln98">    root = (void*)(&amp;CMock_Guts_Buffer[root_index]);</a>
<a name="ln99">    obj  = (void*)(&amp;CMock_Guts_Buffer[obj_index]);</a>
<a name="ln100"> </a>
<a name="ln101">    /* find the end of the existing chain and add us */</a>
<a name="ln102">    next = root;</a>
<a name="ln103">    do {</a>
<a name="ln104">      index = *(CMOCK_MEM_INDEX_TYPE*)((CMOCK_MEM_PTR_AS_INT)next - CMOCK_MEM_INDEX_SIZE);</a>
<a name="ln105">      if (index &gt;= CMock_Guts_FreePtr)</a>
<a name="ln106">        return CMOCK_GUTS_NONE;</a>
<a name="ln107">      if (index &gt; 0)</a>
<a name="ln108">        next = (void*)(&amp;CMock_Guts_Buffer[index]);</a>
<a name="ln109">    } while (index &gt; 0);</a>
<a name="ln110">    *(CMOCK_MEM_INDEX_TYPE*)((CMOCK_MEM_PTR_AS_INT)next - CMOCK_MEM_INDEX_SIZE) = (CMOCK_MEM_INDEX_TYPE)((CMOCK_MEM_PTR_AS_INT)obj - (CMOCK_MEM_PTR_AS_INT)CMock_Guts_Buffer);</a>
<a name="ln111">    return root_index;</a>
<a name="ln112">  }</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">/*-------------------------------------------------------</a>
<a name="ln116"> * CMock_Guts_MemNext</a>
<a name="ln117"> *-------------------------------------------------------*/</a>
<a name="ln118">CMOCK_MEM_INDEX_TYPE CMock_Guts_MemNext(CMOCK_MEM_INDEX_TYPE previous_item_index)</a>
<a name="ln119">{</a>
<a name="ln120">  CMOCK_MEM_INDEX_TYPE index;</a>
<a name="ln121">  void* previous_item;</a>
<a name="ln122"> </a>
<a name="ln123">  /* There is nothing &quot;next&quot; if the pointer isn't from our buffer */</a>
<a name="ln124">  if ((previous_item_index &lt; CMOCK_MEM_ALIGN_SIZE) || (previous_item_index  &gt;= CMock_Guts_FreePtr))</a>
<a name="ln125">    return CMOCK_GUTS_NONE;</a>
<a name="ln126">  previous_item = (void*)(&amp;CMock_Guts_Buffer[previous_item_index]);</a>
<a name="ln127"> </a>
<a name="ln128">  /* if the pointer is good, then use it to look up the next index</a>
<a name="ln129">   * (we know the first element always goes in zero, so NEXT must always be &gt; 1) */</a>
<a name="ln130">  index = *(CMOCK_MEM_INDEX_TYPE*)((CMOCK_MEM_PTR_AS_INT)previous_item - CMOCK_MEM_INDEX_SIZE);</a>
<a name="ln131">  if ((index &gt; 1) &amp;&amp; (index &lt; CMock_Guts_FreePtr))</a>
<a name="ln132">    return index;</a>
<a name="ln133">  else</a>
<a name="ln134">    return CMOCK_GUTS_NONE;</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">/*-------------------------------------------------------</a>
<a name="ln138"> * CMock_Guts_MemEndOfChain</a>
<a name="ln139"> *-------------------------------------------------------*/</a>
<a name="ln140">CMOCK_MEM_INDEX_TYPE CMock_Guts_MemEndOfChain(CMOCK_MEM_INDEX_TYPE root_index)</a>
<a name="ln141">{</a>
<a name="ln142">  CMOCK_MEM_INDEX_TYPE index = root_index;</a>
<a name="ln143">  CMOCK_MEM_INDEX_TYPE next_index;</a>
<a name="ln144"> </a>
<a name="ln145">  for (next_index = root_index;</a>
<a name="ln146">       next_index != CMOCK_GUTS_NONE;</a>
<a name="ln147">       next_index = CMock_Guts_MemNext(index))</a>
<a name="ln148">  {</a>
<a name="ln149">    index = next_index;</a>
<a name="ln150">  }</a>
<a name="ln151"> </a>
<a name="ln152">  return index;</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">/*-------------------------------------------------------</a>
<a name="ln156"> * CMock_GetAddressFor</a>
<a name="ln157"> *-------------------------------------------------------*/</a>
<a name="ln158">void* CMock_Guts_GetAddressFor(CMOCK_MEM_INDEX_TYPE index)</a>
<a name="ln159">{</a>
<a name="ln160">  if ((index &gt;= CMOCK_MEM_ALIGN_SIZE) &amp;&amp; (index &lt; CMock_Guts_FreePtr))</a>
<a name="ln161">  {</a>
<a name="ln162">    return (void*)(&amp;CMock_Guts_Buffer[index]);</a>
<a name="ln163">  }</a>
<a name="ln164">  else</a>
<a name="ln165">  {</a>
<a name="ln166">    return NULL;</a>
<a name="ln167">  }</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">/*-------------------------------------------------------</a>
<a name="ln171"> * CMock_Guts_MemBytesCapacity</a>
<a name="ln172"> *-------------------------------------------------------*/</a>
<a name="ln173">CMOCK_MEM_INDEX_TYPE CMock_Guts_MemBytesCapacity(void)</a>
<a name="ln174">{</a>
<a name="ln175">  return (sizeof(CMock_Guts_Buffer) - CMOCK_MEM_ALIGN_SIZE);</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">/*-------------------------------------------------------</a>
<a name="ln179"> * CMock_Guts_MemBytesFree</a>
<a name="ln180"> *-------------------------------------------------------*/</a>
<a name="ln181">CMOCK_MEM_INDEX_TYPE CMock_Guts_MemBytesFree(void)</a>
<a name="ln182">{</a>
<a name="ln183">  return CMock_Guts_BufferSize - CMock_Guts_FreePtr;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">/*-------------------------------------------------------</a>
<a name="ln187"> * CMock_Guts_MemBytesUsed</a>
<a name="ln188"> *-------------------------------------------------------*/</a>
<a name="ln189">CMOCK_MEM_INDEX_TYPE CMock_Guts_MemBytesUsed(void)</a>
<a name="ln190">{</a>
<a name="ln191">  return CMock_Guts_FreePtr - CMOCK_MEM_ALIGN_SIZE;</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">/*-------------------------------------------------------</a>
<a name="ln195"> * CMock_Guts_MemFreeAll</a>
<a name="ln196"> *-------------------------------------------------------*/</a>
<a name="ln197">void CMock_Guts_MemFreeAll(void)</a>
<a name="ln198">{</a>
<a name="ln199">  CMock_Guts_FreePtr = CMOCK_MEM_ALIGN_SIZE; /* skip the very beginning */</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">/*-------------------------------------------------------</a>
<a name="ln203"> * CMock_Guts_MemFreeFinal</a>
<a name="ln204"> *-------------------------------------------------------*/</a>
<a name="ln205">void CMock_Guts_MemFreeFinal(void)</a>
<a name="ln206">{</a>
<a name="ln207">  CMock_Guts_FreePtr = CMOCK_MEM_ALIGN_SIZE;</a>
<a name="ln208">#ifdef CMOCK_MEM_DYNAMIC</a>
<a name="ln209">  if (CMock_Guts_Buffer)</a>
<a name="ln210">  {</a>
<a name="ln211">    free(CMock_Guts_Buffer);</a>
<a name="ln212">    CMock_Guts_Buffer = NULL;</a>
<a name="ln213">  }</a>
<a name="ln214">#endif</a>
<a name="ln215">}</a>
<a name="ln216"> </a>

</code></pre>
<div class="balloon" rel="1"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v009/" target="_blank">V009</a> To use free version of PVS-Studio, source code files are required to start with a special comment.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
